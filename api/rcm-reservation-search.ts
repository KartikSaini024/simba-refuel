import type { VercelRequest, VercelResponse } from '@vercel/node';
import https from 'https';
import querystring from 'querystring';

export default async function handler(req: VercelRequest, res: VercelResponse) {
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method Not Allowed' });
    }

    try {
        const { rego, cookies, dateStr } = req.body;

        if (!rego || !cookies || !dateStr) {
            return res.status(400).json({ error: 'Missing required fields: rego, cookies, dateStr' });
        }

        // Step 1: GET search page to get ViewState (with Redirect Handling)
        const fetchWithRedirects = async (hostname: string, path: string, cookies: string): Promise<{ body: string, headers: any }> => {
            let currentPath = path;
            let currentHostname = hostname;
            let redirectCount = 0;
            const maxRedirects = 5;

            while (redirectCount < maxRedirects) {
                const options = {
                    hostname: currentHostname,
                    path: currentPath,
                    method: 'GET',
                    headers: {
                        'Cookie': cookies,
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                    }
                };

                const response = await new Promise<{ body: string, headers: any, statusCode?: number }>((resolve, reject) => {
                    const req = https.request(options, (res) => {
                        let data = '';
                        res.on('data', (chunk) => data += chunk);
                        res.on('end', () => resolve({ body: data, headers: res.headers, statusCode: res.statusCode }));
                    });
                    req.on('error', reject);
                    req.end();
                });

                // Handle Redirects
                if (response.statusCode && [301, 302, 303, 307, 308].includes(response.statusCode)) {
                    const location = response.headers.location;
                    if (location) {
                        console.log(`[RCM Search API] Redirecting to: ${location}`);
                        // Handle relative or absolute URLs
                        if (location.startsWith('http')) {
                            const url = new URL(location);
                            currentHostname = url.hostname;
                            currentPath = url.pathname + url.search;
                        } else {
                            currentPath = location;
                        }
                        redirectCount++;
                        continue;
                    }
                }

                return response;
            }
            throw new Error('Too many redirects');
        };

        const getResponse = await fetchWithRedirects('bookings.rentalcarmanager.com', '/report/reservation_enquiry', cookies);

        // Extract Hidden Fields
        const viewStateMatch = getResponse.body.match(/id="__VIEWSTATE" value="(.*?)"/);
        const viewStateGenMatch = getResponse.body.match(/id="__VIEWSTATEGENERATOR" value="(.*?)"/);
        const eventValidationMatch = getResponse.body.match(/id="__EVENTVALIDATION" value="(.*?)"/);

        if (!viewStateMatch) {
            throw new Error('Failed to find ViewState on search page. Session may be expired.');
        }

        const viewState = viewStateMatch[1];
        const viewStateGenerator = viewStateGenMatch ? viewStateGenMatch[1] : '';
        const eventValidation = eventValidationMatch ? eventValidationMatch[1] : '';

        // Step 2: POST Search
        const postData = querystring.stringify({
            '__EVENTTARGET': 'ctl00$MainBodyContent$butRunReport',
            '__EVENTARGUMENT': '',
            '__VIEWSTATE': viewState,
            '__VIEWSTATEGENERATOR': viewStateGenerator,
            '__EVENTVALIDATION': eventValidation,
            'searchfor': '',
            'cmbReportLocationID': '0',
            'txtStartingDay197': dateStr,
            'txtEndingDay197': dateStr,
            'cmbsSearchFor': 'registrationno',
            'txtsSearchString197': rego,
            'cmbApplyDateRate': 'All',
            'hidSeeAllFleet': 'Yes',
            'hidAccessLevel': '100',
            'hidBranchID': '9',
            'Confirmed_length': '-1',
            'ctl00$MainBodyContent$reportcode': 'reservation_enquiry',
            'ctl00$MainBodyContent$PageNo': '0',
            'ctl00$MainBodyContent$ItemsPerPage': '0',
            'ctl00$MainBodyContent$AutoGenerated': '0',
            'ctl00$MainBodyContent$ServerSide': 'False',
            'ctl00$MainBodyContent$fxdHdr': '1',
            'ctl00$MainBodyContent$hdnReportData': '{}',
            'ctl00$MainBodyContent$hdnSummaryFields': '{}'
        });

        const postOptions = {
            hostname: 'bookings.rentalcarmanager.com',
            path: '/report/reservation_enquiry',
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Content-Length': Buffer.byteLength(postData),
                'Cookie': cookies,
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Origin': 'https://bookings.rentalcarmanager.com',
                'Referer': 'https://bookings.rentalcarmanager.com/report/reservation_enquiry'
            }
        };

        const postResponse = await new Promise<{ body: string, statusCode?: number }>((resolve, reject) => {
            const request = https.request(postOptions, (response) => {
                let data = '';
                response.on('data', (chunk) => data += chunk);
                response.on('end', () => resolve({ body: data, statusCode: response.statusCode }));
            });
            request.on('error', reject);
            request.write(postData);
            request.end();
        });

        // Step 3: Parse Results
        const tableMatch = postResponse.body.match(/<table[^>]*id="Confirmed"[^>]*>([\s\S]*?)<\/table>/);

        interface ReservationResult {
            resNo: string;
            customer: string;
            vehicle: string;
            dropOff: string;
            rawHtml: string;
        }

        const results: ReservationResult[] = [];

        if (tableMatch) {
            const tableContent = tableMatch[1];
            // Look for <tr>
            const rows = tableContent.match(/<tr[\s\S]*?<\/tr>/g);

            if (rows) {
                rows.forEach(row => {
                    // Skip header
                    if (row.includes('<th')) return;

                    // Extract Res No
                    const resNoMatch = row.match(/ReportPopup\('[^']+\/(\d+)\//);
                    const resNo = resNoMatch ? resNoMatch[1] : '';

                    // Extract Customer
                    const cells = row.match(/<td[^>]*>([\s\S]*?)<\/td>/g);
                    if (cells && cells.length > 4 && resNo) {
                        // Normalize texts
                        const clean = (s: string) => s.replace(/<[^>]+>/g, '').trim();

                        const customer = clean(cells[4]); // 5th cell
                        const vehicle = clean(cells[6]);  // 7th cell

                        // Dynamic Drop Off extraction
                        let maxDate = 0;
                        let dropOff = '';

                        cells.forEach(cell => {
                            const text = clean(cell);
                            const dateMatch = text.match(/(?:[A-Za-z]{3}\s+)?(\d{1,2}\/[A-Za-z]{3}\/\d{4}(?:\s+\d{1,2}:\d{2})?)/);

                            if (dateMatch) {
                                const dateString = dateMatch[1].replace(/\//g, ' ');
                                const ts = Date.parse(dateString);
                                if (!isNaN(ts)) {
                                    if (ts > maxDate) {
                                        maxDate = ts;
                                        dropOff = text;
                                    }
                                }
                            }
                        });

                        if (!dropOff && cells.length > 10) {
                            dropOff = clean(cells[10]);
                        }

                        results.push({
                            resNo,
                            customer,
                            vehicle,
                            dropOff,
                            rawHtml: row
                        });
                    }
                });
            }
        }

        return res.status(200).json({ success: true, results });

    } catch (err: any) {
        console.error('[RCM Search API] Error:', err);
        return res.status(500).json({ error: err.message });
    }
}
